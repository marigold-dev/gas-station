# An introduction to off-chain permits

In the [Tutorial](./tutorial.md) chapter, we demonstrate how to transfer an NFT to a smart contract
through the Gas Station. However, an issue arises as the corresponding operation is ultimately going to be posted by the Gas
Station account. The concern is how the NFT contract will allow this transfer on behalf of the user.

FA2 contracts, used to implement NFTs, support the concept of *operator*
accounts acting on behalf of the user. However, only the original owner of the NFT can authorize a new operator to do so.
The simplest way would be to modify the NFT contract to:

* Make the Gas Station account a super-user of the contract.
* Let this account [register third-party contracts as
  operators](https://tezostaquito.io/docs/fa2_parameters/#the-update_operators-entrypoint), which
  would allow the transfer to happen.

This, of course, introduces a security (and potentially legal) concern. If the key of the Marigold
Gas Station account is stolen, multiple FA2 contracts could be compromised as a consequence.
On the other hand, users whose operations are sponsored are not expected to have any tez in their wallets,
preventing them from independently posting the `update_operator` call on-chain.

So, what is the solution?

## Off-chain permits

To address this problem securely, the concept of *off-chain permits* was introduced through [TZIP
17](https://tzip.tezosagora.org/proposal/tzip-17/). This enhancement extends the FA2 standard with several new
entrypoints. The most noteworthy one, aptly named `permit`, can be invoked by anyone. It anticipates a list of
authorizations for transfers that are signed by the respective owners. Importantly, these transfers are signed off-chain.
This implies that the application must prompt users for their signatures through conventional means, such as a
Beacon-compatible wallet. However, the obtained signature must then be stored and/or transmitted to this entrypoint by another account.

However, in most cases, these permits can be included in the same transaction as the call to the other contract,
as demonstrated in the previous chapter. When a permit is registered by the contract, it functions as a one-time
authorization for a transfer to a specific address, which can either be a contract or an implicit account.
The `transfer` entrypoint maintains the same interface as an ordinary FA2
contract and, naturally, supports the same interface as before, including regular operators. This implies
that regular users, who do not require their transactions to be relayed by the gas station, can always
utilize their assets in a normal, permissionless manner.

Let's define permits: they consist of signed bytes formed from 4 parameters:

* The chain identifier ensures that a permit signed for a given chain (such as Ghostnet) cannot be used on a different chain.
* The address of the permit FA2 contract ensures that a permit signed for a particular NFT collection cannot be used on another one.
* A counter (nonce) defined inside the contract ensures that a permit can only be used once.
* Finally, a hash of the allowed operation, which is checked when the
  transfer takes place.

If you recall [the previous chapter](./tutorial.md), this byte string was computed by the library using the following call:

```ts
const permitData = await permitContract.generatePermit({
  from_: userAddress,
  txs: [{
    to_: RECIPIENT,
    token_id,
    amount: 1
  }]
});
```

Indeed, forming it manually can be a little bit complicated, and the slightest error can cause the permit fail silently.

Once signed by the user, the permit can be registered in the contract by invoking the `permit`
entrypoint. This entrypoint expects a list of parameters of the form `(public_key, signature, transfer_hash)`
where `public_key` is the user's public key, necessary for verifying the `signature`. Notably, this
`signature` is computed from the entire byte string, not just the `transfer_hash`.

If you choose to compute permits manually, be mindful that they are actually generated by forming
the following pair: `((chain_identifier, contract_address), (contract_counter, transfer_hash))`.
It's advisble to refer to the documentation of the contract library you are using to ensure accuracy.

## How to deploy a permit contract

The most up-to-date implementation of TZIP 17-style permits is available in [the permit-cameligo Ligo
package](https://github.com/aguillon/permit-cameligo/), which is currently maintained outside of the
Ligo Package Registry website. To use it, it is recommended to clone the following repository and
utilize the Ligo compiler to install the dependencies:

```bash
$ git clone https://github.com/aguillon/permit-cameligo
$ cd permit-cameligo/
$ make install
$ make compile
```

Note that the Makefile assumes that you are running the dockerized version of Ligo. If you want to use another one,
such as a local version, you can prefix the `make` commands with `ligo_compiler=ligo `. For example:

```bash
$ ligo_compiler=ligo make install
$ ligo_compiler=ligo make compile
```

This installs the dependencies in `.ligo/`, and compiles the code, generating two files in `compiled/`.
The first file is a JSONized version of the second, which is ready to be deployed using the scripts in `deploy/`.
Alongside the compiled code, this script requires two additional files:
`deploy/metadata.json` containing the contract's metadata, and `deploy/.env` which holds the secret key and the RPC node information.

Let's create a minimal `deploy/metadata.json` file:

```json
{
  "name":"Example",
  "interfaces":[
    "TZIP-12"
  ]
}
```

Customize this file according to your requirements. If you only want to test the deployment script, you can
also utilize the pre-generated `deploy/metadata.json.dist` file and rename it to `deploy/metadata.json`.
Similarly, copy `deploy/.env.dist` to `deploy/.env` and edit the file to include your secret key:

```bash
# Required: Your private key
PK=edsk...
# Required: see https://tezostaquito.io/docs/rpc_nodes/
RPC_URL=https://ghostnet.tezos.marigold.dev/
```

Finally, you should be able to

```bash
$ cd deploy/
$ npm i
$ npm run start
```

This workflow assumes that you will mint each token individually by invoking the
`create_token` entrypoint. If you prefer to pre-mint some tokens, you will need to modify the
`deploy/deploy.ts` script to begin with a non-empty `token_metadata` map.
The script should output the address of the contract after origination.
