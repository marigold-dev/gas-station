<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Gas Station Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="marigold-docs-theme/marigold.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="welcome.html">Welcome</a></li><li class="chapter-item expanded affix "><a href="webapp.html">Gas Station Webapp</a></li><li class="chapter-item expanded affix "><a href="library.html">SDKs</a></li><li class="chapter-item expanded affix "><a href="api.html">API</a></li><li class="chapter-item expanded affix "><a href="tutorial.html">Tutorial</a></li><li class="chapter-item expanded affix "><a href="permits.html">Permits</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Gas Station Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/marigold-dev/gas-station" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="marigold-gas-station-documentation"><a class="header" href="#marigold-gas-station-documentation">Marigold Gas Station documentation</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>The Gas Station is a tool allowing developers to sponsor the transactions of their users. It can be
used to facilitate user onboarding, or to implement a specific economic model (e.g., users can
mint a NFT freely, but pay a fee when reselling it) which does not need the user to possess tez.</p>
<p>The Gas Station would typically be used by video game developers to subsidize activities for
users. It does not require these users to do any transaction or reveal their account, as the Gas
Station account independently processes those transactions. However, it's important to note that
this workflow may necessitate the use of specific smart contract patterns, such as permit (TZIP 17).</p>
<p>Currently, the API URL for Ghostnet is:
<a href="https://ghostnet.gas-station-api.marigold.dev">https://ghostnet.gas-station-api.marigold.dev</a>. The
Gas Station is not yet available on the Mainnet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gas-station-webapp"><a class="header" href="#gas-station-webapp">Gas Station Webapp</a></h1>
<p>The Gas Station webapp allows developers to manage sponsored contracts and operations as well as
their budget. It also allows to express basic conditions on the spending of credits, for instance by
giving a maximum budget per day.</p>
<p>The webapp is hosted by Marigold: <a href="https://ghostnet.gas-station.marigold.dev/">Gas Station webapp on Ghostnet</a>.</p>
<p>⚠️ Note: currently available only on Ghostnet ⚠️</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<h3 id="wallet-connection"><a class="header" href="#wallet-connection">Wallet connection</a></h3>
<p>Like all dApps, one of the first things to do is connect your wallet by clicking on the button in the top right corner.</p>
<p><img src="./assets/wallet_connection.png" alt="Wallet connection" /></p>
<h3 id="your-contracts"><a class="header" href="#your-contracts">Your contracts</a></h3>
<p>The homepage lists all the contracts registered in the Gas Station as well as their entrypoints.
Entrypoints can be activated or deactivated, depending on if the operations targeting those entrypoints
should be sponsored or not.</p>
<p><img src="./assets/homepage.png" alt="Homepage" /></p>
<h3 id="add-a-new-contract"><a class="header" href="#add-a-new-contract">Add a new contract</a></h3>
<p>To add a new contract, click on <code>Add contract</code> and fill in the required information. Start by entering the contract address to retrieve the associated entrypoints for your contract. Then, name the contract and activate the entrypoints which you want to sponsor.</p>
<p><img src="./assets/add-contract.png" alt="Add contract" /></p>
<h3 id="add-credits-to-your-vault"><a class="header" href="#add-credits-to-your-vault">Add credits to your vault</a></h3>
<p>The Gas Station sponsors operations to your contracts using the tez you have put in a vault. To add credits to your vault, go to the <code>My credits</code> page. Enter the amount of tez you want to send and confirm. After a few seconds, your vault balance and overall balance will be updated.</p>
<p><img src="./assets/add-credits.png" alt="Add credits" /></p>
<h3 id="withdraw-credits"><a class="header" href="#withdraw-credits">Withdraw credits</a></h3>
<p>You can also withdraw tez from your vault. On the <code>My credits</code> page, enter the amount of tez you want to withdraw and confirm. For security reasons, we require a signature which depends on the vault, the amount, and a withdraw counter which is stored in the database.</p>
<h3 id="test"><a class="header" href="#test">Test</a></h3>
<p>Once the contract is added and credits are transferred to your vault, you can integrate the Gas Station into your dApps by following this <a href="./tutorial.html">guide</a>. This will allow you to test the seamless integration of the Gas Station with your dApps.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sdks"><a class="header" href="#sdks">SDKs</a></h1>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h2>
<p>We propose two SDKs (in TypeScript and in Unity) to use the Gas Station from your applications.</p>
<h3 id="typescript"><a class="header" href="#typescript">Typescript</a></h3>
<h4 id="installation"><a class="header" href="#installation">Installation</a></h4>
<p>To install the Typescript SDK in your project, run:</p>
<pre><code class="language-bash">npm install --save @marigold-dev/gas-station-lib
</code></pre>
<h4 id="explanations"><a class="header" href="#explanations">Explanations</a></h4>
<p>The SDK consists of two classes: <code>GasStation</code> and <code>PermitContract</code>.</p>
<p>There are also two variables:</p>
<ul>
<li><code>GAS_STATION_PUBLIC_API_GHOSTNET</code> which redirect to <a href="https://ghostnet.gas-station-api.marigold.dev/operation">https://ghostnet.gas-station-api.marigold.dev/operation</a></li>
<li><code>GAS_STATION_PUBLIC_API_MAINNET</code> which redirect to <a href="https://gas-station-api.marigold.dev/operation">https://gas-station-api.marigold.dev/operation</a> (Not available yet)</li>
</ul>
<p>The <code>GasStation</code> class enables easy communication with the Gas Station API without the need to manually initialize the HTTP request.</p>
<p>To initialize this class, you need to provide it with a Gas Station API URL. For now, you can use <code>https://gas-station-api.marigold.dev/operation</code>.</p>
<p>The class has two methods:</p>
<ul>
<li><code>postOperation</code> takes a <code>sender</code> parameter (usually the user's address) and an <code>operation</code> of the following type:</li>
</ul>
<pre><code class="language-ts">export type Operation = {
  destination: string;
  parameters: unknown;
};
</code></pre>
<p>This method then prepares the HTTP request and sends it to the <code>/operation</code> endpoint of the API, which processes the operation.</p>
<ul>
<li><code>postOperations</code> also takes a <code>sender</code> and an array of <code>Operation</code>, allowing you to send multiple
operations at once. These operations will be treated atomically by the API: if the simulation of
one operation fails, then they are all discarded.</li>
</ul>
<p>The <code>PermitContract</code> class allows the generation of a off-chain permit <a href="https://tzip.tezosagora.org/proposal/tzip-17">TZIP-17</a> for a contract implementing TZIP-17.</p>
<blockquote>
<p>A permit is an authorization to call a specific endpoint of a smart contract with a specified parameter on behalf of a given address. This authorization may have an expiration. It is particularly useful for handling FA tokens when the user has ownership (transfer, update_operation, approve).</p>
</blockquote>
<p>This class has two methods:</p>
<ul>
<li><code>generatePermit</code> creates a permit from a transfer operation. It returns an object containing:</li>
</ul>
<pre><code class="language-ts">{
  bytes: string, // the bytes containing the permit
  transfer_hash: string, // the hash of the transfer operation
}
</code></pre>
<p>After calling <code>generatePermit</code>, you need to ask the token owner for their signature.</p>
<ul>
<li><code>permitCall</code> generates the permit operation using the <code>permit</code> entrypoint on the target contract. This method takes an object of type:</li>
</ul>
<pre><code class="language-ts">type PermitOperation = {
  publicKey: string;
  signature: string;
  transferHash: string;
};
</code></pre>
<p>and returns an operation of type <code>TransferParams</code>, which can be sent using the GasStation class.</p>
<h4 id="usage-1"><a class="header" href="#usage-1">Usage</a></h4>
<p>First import and initialize the <code>GasStation</code> object from the SDK:</p>
<pre><code class="language-ts">import { GasStation } from '@marigold-dev/gas-station-lib'

const gasApi = new GasStation()
</code></pre>
<p>ℹ️ NOTE: By default, the Gas Station used by the SDK is the Marigold one on Ghostnet but you can also provide a <code>apiURL</code> like:</p>
<pre><code class="language-ts">import { GasStation, GAS_STATION_PUBLIC_API_GHOSTNET} from '@marigold-dev/gas-station-lib'

const gasApi = new GasStation({
  apiURL: GAS_STATION_PUBLIC_API_GHOSTNET // or the URL directly
})
</code></pre>
<p>Next, you can forge your operation, for example, to mint an NFT (assuming the contract has a <code>mint_token</code> entrypoint):</p>
<pre><code class="language-ts">const mintOperation = await contract.methodsObject.mint_token([{
              owner: userAddress,
              token_id: tokenId,
              amount_: 1
          }]).toTransferParams()
</code></pre>
<p>Finally, you can send your operation to the Gas Station with:</p>
<pre><code class="language-ts">const response = await gasApi.postOperation(userAddress, {
            destination: mintOperation.to,
            parameters: mintOperation.parameter
          });
</code></pre>
<h3 id="unity"><a class="header" href="#unity">Unity</a></h3>
<p>🚧 Work in Progress 🚧</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api"><a class="header" href="#api">API</a></h1>
<iframe width="1080" height="915" src="https://ghostnet.gas-station-api.marigold.dev/docs"></iframe><div style="break-before: page; page-break-before: always;"></div><h1 id="developing-a-web-application-with-the-gas-station"><a class="header" href="#developing-a-web-application-with-the-gas-station">Developing a web application with the Gas Station</a></h1>
<p>This chapter walks through a simple example of a dapp using the Gas Station. You can <a href="https://ghostnet.gas-station-nft-example.marigold.dev">try it online at this address</a>.</p>
<h2 id="template"><a class="header" href="#template">Template</a></h2>
<p>The first step is to retrieve the code template located <a href="https://github.com/marigold-dev/gas-station-nft-example-template">here</a>.
Once retrieved, you can run the following commands:</p>
<pre><code class="language-bash">npm install
npm run check
</code></pre>
<p>ℹ️ Note: If <code>npm run check</code> returns some errors, it's ok. It's just to initialize some Svelte tools.</p>
<p>To test that everything works well, you can use:</p>
<pre><code class="language-bash">npm run dev
</code></pre>
<p>The files of interest are located in <code>src/lib</code>. You will find Svelte components and a <code>tezos.ts</code> file that contains utility functions such as wallet connection, etc.</p>
<p>To distinguish between a simple call to the Gas Station and a more complex examples involving permits, we develop two distinct components, <code>src/lib/MintingComponent.svelte</code> and <code>src/lib/StakingComponent.svelte</code>.
Let's go ! 💪</p>
<h2 id="minting-an-nft"><a class="header" href="#minting-an-nft">Minting an NFT</a></h2>
<p>We'll start with minting an NFT by a user. The contract we'll use is available at this address on Ghostnet: <a href="https://ghostnet.tzkt.io/KT1HUdxmgZUw21ED9gqELVvCty5d1ff41p7J/operations"><code>KT1HUdxmgZUw21ED9gqELVvCty5d1ff41p7J</code></a>.
This contract has an admin, which is the only account allowed to mint NFTs. This is the same
settings as you would have in a video game, where the game decides when to mint an NFT for a user.
In this case, the contract admin has been set to be the Gas Station account, because the <code>mint</code>
entrypoint is always going to be called by the Gas Station.</p>
<p>The goal here is for the user to initiate the mint action and retrieve their NFT without having to
pay gas fees. For this, we will use the <a href="./library.html">TypeScript SDK</a>.</p>
<p>First, we'll setup the GasStation SDK as follows:</p>
<pre><code class="language-ts">const gasStationAPI = new GasStation()
</code></pre>
<p>ℹ️ <code>GasStation</code> class will target the Gas Station deployed on Ghostnet by default.</p>
<p>Next, we'll retrieve an instance of our contract, using <a href="https://tezostaquito.io/">Taquito</a>.</p>
<pre><code class="language-ts">const contract = await Tezos.wallet.at(PUBLIC_PERMIT_CONTRACT);
</code></pre>
<p>ℹ️ The <code>Tezos</code> instance of Taquito is already initialized in the <code>tezos.ts</code> file, so it can be directly imported.</p>
<p>ℹ️ <code>PUBLIC_PERMIT_CONTRACT</code> is an environment variable corresponding to the address of your NFT
contract. It is defined in the <code>.env</code> file.</p>
<p>Afterward, we will forge our operation to send to the Gas Station:</p>
<pre><code class="language-ts">const mintOperation = await contract.methodsObject.mint_token([{
              owner: userAddress,
              token_id: 0,
              amount_: 1
          }]).toTransferParams()
</code></pre>
<p>Using Taquito, we forge a transfer operation on the <code>mint_token</code> entrypoint.
The parameters for this entrypoint are:</p>
<ul>
<li><code>owner</code>: the future owner of the NFT</li>
<li><code>token_id</code>: ID of the token that we are going to mint</li>
<li><code>amount_</code>: the quantity of tokens we want to mint.</li>
</ul>
<p>Finally, once the operation is forged, we can send it to the Gas Station API:</p>
<pre><code class="language-ts">const response = await gasStationAPI.postOperation(userAddress, {
            destination: mintOperation.to,
            parameters: mintOperation.parameter
          });
</code></pre>
<p>The operation will take a few seconds to be processed by the Gas Station (usually 12/15 seconds) if everything is correct.
If an error occurs (insufficient funds, authorization issue for minting the NFT, etc.), an error code will be returned, which you can handle in your dApp to inform the user.</p>
<h2 id="staking-an-nft"><a class="header" href="#staking-an-nft">Staking an NFT</a></h2>
<p>Minting NFTs from a single address is a simple enough example to start. However, a complete
application would typically offer the possibility for the users to transfer or sell their NFTs. As
final users do not have tez in their wallet, all the transactions are posted by the Gas Station.</p>
<p>Despite this centralization, it is still possible to maintain security and non-custodiality using
permits. In this section, we call <em>staking</em> the operation of sending an NFT to a contract. As the
user owns the NFT, it is appropriate to sign a permit (authorization) to perform this transfer.</p>
<p>To facilitate the development of this new feature, we will also use the TypeScript SDK (for reference, you have all the information <a href="./library.html">here</a>)</p>
<p>To start, let's initialize the <code>GasStation</code> and <code>PermitContract</code>  classes from the SDK:</p>
<p>ℹ️ <code>GasStation</code> class will target the Gas Station deployed on Ghostnet by default.</p>
<pre><code class="language-ts">const gasStationApi = new GasStation();
const permitContract = new PermitContract(PUBLIC_PERMIT_CONTRACT, Tezos);
</code></pre>
<p>Now we can generate our permit using the <code>generatePermit</code> method:</p>
<pre><code class="language-ts">const permitData = await permitContract.generatePermit({
        from_: userAddress,
        txs: [{
          to_: PUBLIC_STAKING_CONTRACT,
          token_id,
          amount: 1
        }]
      });
</code></pre>
<p>Some explanations:</p>
<ul>
<li>The variable <code>PUBLIC_STAKING_CONTRACT</code> contains the address of the staking contract (available at this address <a href="https://ghostnet.tzkt.io/KT1VVotciVbvz1SopVfoXsxXcpyBBSryQgEn/operations"><code>KT1VVotciVbvz1SopVfoXsxXcpyBBSryQgEn</code></a> on Ghostnet).</li>
<li>The <code>token_id</code> corresponds to the ID of the token you want to stake.</li>
</ul>
<p><code>permitData</code> then contains the hash of the permit <code>bytes</code> and the hash of transfer operation <code>transfer_hash</code>:</p>
<pre><code class="language-ts">{
    bytes: string;
    transfer_hash: string;
}
</code></pre>
<p>Next, we need to have the owner of the token sign this permit and retrieve the signature.</p>
<p>This is easily done using Taquito:</p>
<pre><code class="language-ts">const signature = (await (await wallet.client).requestSignPayload({
          signingType: SigningType.MICHELINE,
          payload: permit_data.bytes
      })).signature;
</code></pre>
<p>Once we have the signed permit, we can register it with the contract that implements the <code>permit</code> entrypoint.</p>
<p>Again, we can use the SDK for this:</p>
<pre><code class="language-ts">const permitOperation = await permitContract.permitCall({
          publicKey: activeAccount.publicKey,
          signature: signature,
          transferHash: permit_data.transfer_hash
      });
</code></pre>
<ul>
<li><code>publicKey</code> is the public key of the token's owner</li>
<li><code>signature</code> is the signature of the permit obtained in the previous step</li>
<li><code>transferHash</code> is the hash of the transfer operation returned during the permit creation</li>
</ul>
<p>At this point, we have all the necessary information regarding the permit. Now, we can forge the staking operation itself and send everything to the Gas Station.</p>
<p>To forge the staking operation, we follow the usual process: we retrieve the contract instance using Taquito and craft the operation to get the parameters.</p>
<pre><code class="language-ts">const stakingContract = await Tezos.wallet.at(PUBLIC_STAKING_CONTRACT);
const stakingOperation = await stakingContract.methods.stake(
        1,
        userAddress
      ).toTransferParams();
</code></pre>
<p>ℹ️ <code>PUBLIC_STAKING_CONTRACT</code> is also an environment variable containing the staking contract's address.</p>
<p>All that remains is to send the operation to the Gas Station to have the gas fees covered:</p>
<pre><code class="language-ts">const response = await gasStationApi.postOperations(userAddress,
          [
            {
              destination: permitOperation.to,
              parameters: permitOperation.parameter
            },
            {
              destination: stakingOperation.to,
              parameters: stakingOperation.parameter
            }
          ]);
</code></pre>
<p>Here, we use <code>postOperations</code> to submit a batch of operations. This batch contains the operation to
register the permit and the staking operation. When calling the staking contract's <code>stake</code>
entrypoint, the permit will be revealed and consumed.</p>
<p>Similar to the minting operation, the Gas Station will respond in a few tens of seconds.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>This simple example shows how a user without any tez can mint an NFT and transfer it to another
contract in a secure way. This is possible thanks to the Gas Station, which relays the transaction
by paying the fees.</p>
<p>Feel free to send us your feedback and comments on this tutorial. 😃</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="an-introduction-to-off-chain-permits"><a class="header" href="#an-introduction-to-off-chain-permits">An introduction to off-chain permits</a></h1>
<p>In the <a href="./tutorial.html">Tutorial</a> chapter, we show how to transfer a NFT to a smart contract
through the Gas Station. As the corresponding operation is ultimately going to get posted by the Gas
Station account, there is an issue: how is NFT contract going to allow this transfer on behalf of
the user? While FA2 contracts, which are used to implement NFTs, support the concept of <em>operators</em>
accounts acting on the behalf of the user, only the original owner of the NFT can allow a new
operator to do so. The simplest way would be to modify the NFT contract to</p>
<ul>
<li>make the Gas Station account a super-user of the contract, and</li>
<li>let this account <a href="https://tezostaquito.io/docs/fa2_parameters/#the-update_operators-entrypoint">register third-party contracts as
operators</a>, which
would allow the transfer to happen</li>
</ul>
<p>This, of course, creates a security (and, potentially, legal) issue: if the key of Marigold Gas
Station account gets stolen, then several FA 2 contracts could be compromised as well. On the other
hand, users whose operations get sponsored are not supposed to have any tez in their wallet, and
thus cannot post the <code>update_operator</code> call on-chain themselves.</p>
<p>What is the solution, then?</p>
<h2 id="off-chain-permits"><a class="header" href="#off-chain-permits">Off-chain permits</a></h2>
<p>To solve this problem in a secure way, the notion of <em>off-chain permits</em> was introduced by <a href="https://tzip.tezosagora.org/proposal/tzip-17/">TZIP
17</a>. It extends the FA 2 standard with a few new
entrypoints. The most interesting one, itself called <code>permit</code>, can be called by anyone, and
expects a list of authorizations for transfers signed by the owners. Those transfers are signed
off-chain: this means that the application has to ask the users for their signature through the
usual ways (e.g. a Beacon-compatible wallet), but this signature has then to be stored and/or
sent to this entrypoint by another account.</p>
<p>Most of the time, however, these permits can be sent in the same transaction as the call to the
other contract, as we did in the previous chapter. When a permit is registered by the contract, it
acts as a one-time authorization for a transfer to a specific address, which can either be a
contract or a implicit account. The <code>transfer</code> entrypoint has the same interface as an ordinary FA 2
contract and of course supports the same usage as before, including regular operators. This means
that regular users, who don't need their transactions to be relayed by the gas station, can always
use their assets in a normal, permissionless way.</p>
<p>Let's define permits: they are signed bytes, formed from 4 parameters:</p>
<ul>
<li>the chain identifier, such that a permit signed for a given chain (such as Ghostnet) cannot be
used on a different chain;</li>
<li>the address of the permit FA2 contract, such that a permit signed for a given NFT collection
cannot be used on another one;</li>
<li>a counter (nonce) defined inside the contract, such as a permit can only be used once;</li>
<li>and, finally, a hash of the allowed operation, which is going to be checked when the
transfer takes place.</li>
</ul>
<p>If you recall <a href="./tutorial.html">the previous chapter</a>, this byte string was computed by the library
with the following call:</p>
<pre><code class="language-ts">const permitData = await permitContract.generatePermit({
  from_: userAddress,
  txs: [{
    to_: RECIPIENT,
    token_id,
    amount: 1
  }]
});
</code></pre>
<p>Indeed, it can be a little bit complicated to form by hand, and the slightest error makes the permit
fail silently.</p>
<p>Once it is signed by the user, the permit can be registered in the contract by calling the <code>permit</code>
entrypoint, which expects a list of parameters of the form <code>(public_key, signature, transfer_hash)</code>
where <code>public_key</code> is the user's public key, which is necessary to check the <code>signature</code>. This
<code>signature</code> is computed from the whole byte string, not just the <code>transfer_hash</code>.</p>
<p>i If you choose to compute permits by hand, be mindful that they are actually computed by forming
the following couple: <code>((chain_identifier, contract_address), (contract_counter, transfer_hash))</code>.
Check the documentation of the contract library that you are using to be sure.</p>
<h2 id="how-to-deploy-a-permit-contract"><a class="header" href="#how-to-deploy-a-permit-contract">How to deploy a permit contract</a></h2>
<p>The most up-to-date implementation of TZIP 17-style permits is <a href="https://github.com/aguillon/permit-cameligo/">the permit-cameligo Ligo
package</a>, which is currently maintained outside of
Ligo Package Registry website. To use it, it is recommended to clone the following repository and
use the Ligo compiler to install the dependencies:</p>
<pre><code class="language-bash">$ git clone https://github.com/aguillon/permit-cameligo
$ cd permit-cameligo/
$ make install
$ make compile
</code></pre>
<p>Note that the Makefile assumes that you run the dockerized version of Ligo. To use another one, for
instance a local one, you can prefix the <code>make</code> commands with <code>ligo_compiler=ligo </code>. For instance:</p>
<pre><code class="language-bash">$ ligo_compiler=ligo make install
$ ligo_compiler=ligo make compile
</code></pre>
<p>This installs the dependencies in <code>.ligo/</code>, and compiles the code to produce two files in <code>compiled/</code>.
The first of those files is a JSONized version of the second, which is ready to be deployed by the
scripts in <code>deploy/</code>. In addition to the compiled code, this script requires two files:
<code>deploy/metadata.json</code> that contains the contract's metadata, and <code>deploy/.env</code> which contains the
secret key and the RPC node.</p>
<p>Let's create a minimal <code>deploy/metadata.json</code> file:</p>
<pre><code class="language-json">{
  "name":"Example",
  "interfaces":[
    "TZIP-12"
  ]
}
</code></pre>
<p>Change this file according to your needs. If you just want to test the deployment script, you can
also use the pre-generated <code>deploy/metadata.json.dist</code> file and rename it to <code>deploy/metadata.json</code>.
In the same spirit, copy <code>deploy/.env.dist</code> to <code>deploy/.env</code> and edit the file to put your secret
key:</p>
<pre><code class="language-bash"># Required: Your private key
PK=edsk...
# Required: see https://tezostaquito.io/docs/rpc_nodes/
RPC_URL=https://ghostnet.tezos.marigold.dev/
</code></pre>
<p>Finally, you should be able to</p>
<pre><code>$ cd deploy/
$ npm i
$ npm run start
</code></pre>
<p>This workflow assumes that you're going to mint each token individually by calling the
<code>create_token</code> entrypoint. If you want to pre-mint some tokens, you need to edit the
<code>deploy/deploy.ts</code> script to start with a non-empty <code>token_metadata</code> map. The script should print
the address of the contract after origination.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="marigold-docs-theme/marigold.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
